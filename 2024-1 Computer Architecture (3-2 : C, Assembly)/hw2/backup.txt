#include <stdio.h>
#include <stdlib.h>

// 제약조건
// 1. input 으로 주어지는 파일의 한줄은 100자를 넘지 않음.
// 2. input 으로 주어지는 파일의 길이는 100000줄을 넘지 않음. 즉, address trace 길이는 100000줄을 넘지 않음.
#define MAX_ROW     100000
#define MAX_COL     2
#define MAX_INPUT   100

// 구현해야하는 함수
void solution(int cache_size, int block_size, int assoc);
void read_op(int addr, int cache_size, int block_size, int assoc);
void write_op(int addr, int cache_size, int block_size, int assoc);
void fetch_inst(int addr, int cache_size, int block_size, int assoc);
void update_LRU(int set, int way);
int get_LRU(int set);
int get_random(int assoc);

// 전역변수
// 문제를 풀기 위한 힌트로써 제공된 것이며, 마음대로 변환 가능합니다.
enum COLS {
    MODE,
    ADDR
};

int i_total, i_miss;            /* instructino cache 총 접근 횟수, miss 횟수*/
int d_total, d_miss, d_write;   /* data cache 접근 횟수 및 miss 횟수, memory write 횟수 */
int trace[MAX_ROW][MAX_COL] = {{0,0},};
int trace_length = 0;
int **cache;                    /* 캐시 저장 구조 */
int **LRU;                      /* LRU 교체 정책을 위한 구조 */
int *valid;                     /* 유효 비트 저장 구조 */
int sets, ways;                 /* set 수와 way 수 */

void initialize_cache(int cache_size, int block_size, int assoc) {
    sets = cache_size / (block_size * assoc);
    ways = assoc;

    /* 캐시 및 LRU 초기화 */
    cache = (int **)malloc(sets * sizeof(int *));
    LRU = (int **)malloc(sets * sizeof(int *));
    valid = (int *)malloc(sets * ways * sizeof(int));
    for (int i = 0; i < sets; i++) {
        cache[i] = (int *)malloc(ways * sizeof(int));
        LRU[i] = (int *)malloc(ways * sizeof(int));
        for (int j = 0; j < ways; j++) {
            cache[i][j] = -1;
            LRU[i][j] = j;
        }
    }

    i_total = i_miss = d_total = d_miss = d_write = 0;
}

void free_cache() {
    for (int i = 0; i < sets; i++) {
        free(cache[i]);
        free(LRU[i]);
    }
    free(cache);
    free(LRU);
    free(valid);
}

int main(){
	// DO NOT MODIFY -- START --  //
    // cache size
    int cache[5] = {1024, 2048, 4096, 8192, 16384}; 
    // block size
    int block[2] = {16, 64};
    // associatvity e.g., 1-way, 2-way, ... , 8-way
    int associative[4] = {1, 2, 4, 8};
    int i=0,j=0,k=0; 

    /* 입력 받아오기 */
    char input[MAX_INPUT];
    while (fgets(input, sizeof(input), stdin)) {  
        if(sscanf(input, "%d %x\n", &trace[trace_length][MODE], &trace[trace_length][ADDR]) != 2) {
            fprintf(stderr, "error!\n");
        }
        trace_length++;
    }


    /* 캐시 시뮬레이션 */
    printf("cache size || block size || associative || d-miss rate || i-miss rate || mem write\n");
    for(i=0; i<5; i++){
      	for(j=0; j<2; j++){
            for(k=0; k<4; k++){
                solution(cache[i], block[j], associative[k]);
            }
        }
    }
	// DO NOT MODIFY -- END --  //
    return 0;
}

void solution(int cache_size, int block_size, int assoc) {
	initialize_cache(cache_size, block_size, assoc);

	// DO NOT MODIFY -- START --  //
    int mode, addr;
    double i_miss_rate, d_miss_rate;    /* miss rate을 저장하는 변수 */
    int index = 0;

    while(index != trace_length) {
        mode = trace[index][MODE];
        addr = trace[index][ADDR];

        switch(mode) {
            case 0 :
                read_op(addr, cache_size, block_size, assoc);
                d_total++;	
                break;
            case 1 :
                write_op(addr, cache_size, block_size, assoc);
                d_total++;	
                break;
            case 2 :
                fetch_inst(addr, cache_size, block_size, assoc);
                i_total++;	
                break;
        }
        index++;
    }
   	// DO NOT MODIFY -- END --  //
	
    // hint. data cache miss rate 와 intruction cache miss rate를 계산하시오. 
    // ? 에는 알맞는 변수를 넣으면 됩니다.
    i_miss_rate = (double)i_miss / i_total;
    d_miss_rate = (double)d_miss / d_total;

	// DO NOT MODIFY -- START --  //
    printf("%8d\t%8d\t%8d\t%.4lf\t%.4lf\t%8d\n", cache_size, block_size, assoc, d_miss_rate, i_miss_rate, d_write);
	// DO NOT MODIFY -- END --  //
    free_cache();
}

// 아래 함수를 직접 구현하시오, 차례로 읽기, 쓰기, 그리고 인스트럭션 fetch 동작입니다.
void read_op(int addr, int cache_size, int block_size, int assoc) {
    int set_index = (addr / block_size) % sets;
    int tag = addr / (block_size * sets);
    int hit = 0;

    for (int i = 0; i < assoc; i++) {
        if (valid[set_index * assoc + i] && cache[set_index][i] == tag) {
            hit = 1;
            update_LRU(set_index, i);
            break;
        }
    }

    if (!hit) {
        d_miss++;
        int replace_way = get_LRU(set_index);
        cache[set_index][replace_way] = tag;
        update_LRU(set_index, replace_way);
        valid[set_index * assoc + replace_way] = 1;
    }
}

void write_op(int addr, int cache_size, int block_size, int assoc) {
    int set_index = (addr / block_size) % sets;
    int tag = addr / (block_size * sets);
    int hit = 0;

    for (int i = 0; i < assoc; i++) {
        if (valid[set_index * assoc + i] && cache[set_index][i] == tag) {
            hit = 1;
            update_LRU(set_index, i);
            break;
        }
    }

    if (!hit) {
        d_miss++;
        d_write++;
        int replace_way = get_LRU(set_index);
        cache[set_index][replace_way] = tag;
        update_LRU(set_index, replace_way);
        valid[set_index * assoc + replace_way] = 1;
    }
}

void fetch_inst(int addr, int cache_size, int block_size, int assoc) {
    int set_index = (addr / block_size) % sets;
    int tag = addr / (block_size * sets);
    int hit = 0;

    for (int i = 0; i < assoc; i++) {
        if (valid[set_index * assoc + i] && cache[set_index][i] == tag) {
            hit = 1;
            update_LRU(set_index, i);
            break;
        }
    }

    if (!hit) {
        i_miss++;
        int replace_way = get_LRU(set_index);
        cache[set_index][replace_way] = tag;
        update_LRU(set_index, replace_way);
        valid[set_index * assoc + replace_way] = 1;
    }
}

void update_LRU(int set, int way) {
    for (int i = 0; i < ways; i++) {
        if (LRU[set][i] == way) {
            for (int j = i; j > 0; j--) {
                LRU[set][j] = LRU[set][j - 1];
            }
            LRU[set][0] = way;
            break;
        }
    }
}

// hint 1. LRU 알고리즘 교체 정책을 구현하기 위한 함수도 작성하셔서 적용하면 됩니다.
int get_LRU(int set) {
    return LRU[set][ways - 1];
}
// hint 2. Random 알고리즘 교체 정책을 구현하기 위한 함수도 작성하셔서 적용하면 됩니다.
int get_random(int assoc) {
    return rand() % assoc;
}